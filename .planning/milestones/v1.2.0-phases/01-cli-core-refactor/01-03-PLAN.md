---
phase: 01-cli-core-refactor
plan: 03
type: execute
wave: 2
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - src/commands/add.ts
  - src/commands/destroy.ts
  - src/commands/health.ts
  - src/commands/restart.ts
  - src/commands/remove.ts
  - src/core/manage.ts
  - src/core/status.ts
autonomous: true
requirements:
  - REF-01
  - REF-03
  - REF-04
  - REF-05

must_haves:
  truths:
    - "add command delegates server validation and registration to core/manage.ts addServerRecord()"
    - "destroy command delegates cloud deletion to core/manage.ts destroyCloudServer() and only handles CLI prompts and output"
    - "health command delegates health check logic to core/status.ts checkCoolifyHealth()"
    - "restart command delegates cloud reboot to a new core/ function and only handles CLI prompts and output"
    - "All five refactored commands produce identical output and behavior"
  artifacts:
    - path: "src/commands/add.ts"
      provides: "Thin CLI wrapper for server registration"
      contains: "import.*from.*core/manage"
    - path: "src/commands/destroy.ts"
      provides: "Thin CLI wrapper for server destruction"
      contains: "import.*from.*core/manage"
    - path: "src/commands/health.ts"
      provides: "Thin CLI wrapper for health checking"
      contains: "import.*from.*core/status"
    - path: "src/commands/restart.ts"
      provides: "Thin CLI wrapper for server reboot"
      contains: "import.*from.*core/manage"
  key_links:
    - from: "src/commands/add.ts"
      to: "src/core/manage.ts"
      via: "import { addServerRecord }"
      pattern: "addServerRecord"
    - from: "src/commands/destroy.ts"
      to: "src/core/manage.ts"
      via: "import { destroyCloudServer }"
      pattern: "destroyCloudServer"
    - from: "src/commands/restart.ts"
      to: "src/core/manage.ts"
      via: "import { rebootServer }"
      pattern: "rebootServer"
---

<objective>
Refactor add, destroy, health, restart, and remove commands to delegate business logic to core/ modules.

Purpose: These commands currently contain provider API calls, validation, and state management directly in the command file. After refactoring, they will be thin wrappers that handle only CLI concerns (prompts, confirmations, spinners, output formatting) and delegate all business logic to core/.

Output: Five thinner command files. Core/manage.ts gains a `rebootServer()` function. Core/status.ts already has the health check function.
</objective>

<execution_context>
@C:/Users/Omrfc/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Omrfc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-cli-core-refactor/01-CONTEXT.md
@.planning/phases/01-cli-core-refactor/01-01-SUMMARY.md
@.planning/phases/01-cli-core-refactor/01-02-SUMMARY.md

<interfaces>
<!-- Core functions already available in core/manage.ts -->
```typescript
export async function addServerRecord(params: AddServerParams): Promise<AddServerResult>
export function removeServerRecord(query: string): RemoveServerResult
export async function destroyCloudServer(query: string): Promise<DestroyServerResult>
export function isSafeMode(): boolean
export function isValidProvider(provider: string): boolean
export function validateIpAddress(ip: string): string | null
export function validateServerName(name: string): string | null
```

<!-- Core functions already available in core/status.ts -->
```typescript
export async function checkCoolifyHealth(ip: string): Promise<"running" | "not reachable">
export async function getCloudServerStatus(server: ServerRecord, apiToken: string): Promise<string>
export async function checkServerStatus(server: ServerRecord, apiToken: string): Promise<StatusResult>
```

<!-- Missing: rebootServer needs to be added to core/manage.ts -->
<!-- restart command currently calls provider.rebootServer() directly -->
```typescript
// To be added:
export interface RebootServerResult {
  success: boolean;
  server?: ServerRecord;
  error?: string;
  hint?: string;
}
export async function rebootServer(query: string): Promise<RebootServerResult>
```
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor add.ts and destroy.ts to delegate to core/manage.ts</name>
  <files>src/commands/add.ts, src/commands/destroy.ts</files>
  <action>
**add.ts refactoring:**

Current add.ts does: provider validation, API token prompting, IP validation, SSH verification, server record creation — all inline. Core/manage.ts already has `addServerRecord()` that does all this.

1. Rewrite `addCommand` to be a thin CLI wrapper:
   - Keep: interactive prompts (inquirer for provider, IP, name if not provided via options)
   - Keep: spinner/logger output formatting
   - Delegate: Call `addServerRecord(params)` from core/manage.ts for actual logic
   - Map result: `result.success` → spinner.succeed + logger output; `!result.success` → spinner.fail + logger.error(result.error)

2. Remove all direct imports of: `getServers`, `saveServer`, `createProviderWithToken`, `sshExec`, `checkSshAvailable` from add.ts — these are now encapsulated in `addServerRecord`.

3. Keep import of: `promptApiToken` (for CLI token prompting before calling core), `logger`, `ora`/`createSpinner`.

4. NOTE: Current add.ts uses `promptApiToken()` interactively. Core/manage.ts `addServerRecord()` reads token from env. For CLI, set the env var before calling core, or add token as optional param to `addServerRecord`. Choose: pass token as optional param (cleaner).
   - If `addServerRecord` doesn't accept token param, modify core/manage.ts to accept optional `apiToken` param that overrides env lookup.

**destroy.ts refactoring:**

Current destroy.ts does: server resolve, double confirmation, API token prompt, provider.destroyServer(), removeServer(), error handling with not-found fallback.

1. Rewrite `destroyCommand` to:
   - Keep: `resolveServer()` call (CLI server selection)
   - Keep: Double confirmation prompts (inquirer confirm + name typing)
   - Keep: `promptApiToken()` call
   - Delegate: Set env token (or pass as param), call `destroyCloudServer(server.name)` from core/manage.ts
   - Map result: success → spinner.succeed; hint (not found) → spinner.warn + logger.info; error → spinner.fail + logger.error + prompt to remove local

2. Note: Current destroy.ts prompts user interactively if cloud deletion fails ("Remove from local config anyway?"). Core's `destroyCloudServer` returns result with error — command handles the interactive fallback.

3. Current destroy.ts passes `query` to resolveServer then uses server object. Core's `destroyCloudServer` accepts a query string and does `findServer` internally. The command should use `resolveServer()` for interactive selection, then pass `server.name` or `server.ip` to core.

Each refactored command: separate commit with tests passing.
  </action>
  <verify>
    <automated>npm run build && npm test -- --testPathPattern="(add|destroy)" 2>&1 | tail -10</automated>
  </verify>
  <done>add.ts delegates to addServerRecord from core/manage.ts. destroy.ts delegates to destroyCloudServer from core/manage.ts. Both only handle CLI concerns. Tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add rebootServer to core/manage.ts and refactor restart.ts, health.ts</name>
  <files>src/core/manage.ts, src/commands/restart.ts, src/commands/health.ts</files>
  <action>
**Add rebootServer to core/manage.ts:**

1. Add a new `rebootServer` function to `src/core/manage.ts`:

```typescript
export interface RebootServerResult {
  success: boolean;
  server?: ServerRecord;
  error?: string;
  hint?: string;
}

export async function rebootServer(query: string): Promise<RebootServerResult> {
  const server = findServer(query);
  if (!server) {
    return { success: false, error: `Server not found: ${query}` };
  }

  if (server.id.startsWith("manual-")) {
    return {
      success: false,
      server,
      error: `Server "${server.name}" was manually added. Reboot is only available for cloud-provisioned servers.`,
    };
  }

  const token = getProviderToken(server.provider);
  if (!token) {
    return {
      success: false,
      server,
      error: `No API token for ${server.provider}. Set ${server.provider.toUpperCase()}_TOKEN environment variable`,
    };
  }

  try {
    const provider = createProviderWithToken(server.provider, token);
    await provider.rebootServer(server.id);
    return { success: true, server };
  } catch (error: unknown) {
    const hint = mapProviderError(error, server.provider);
    return {
      success: false,
      server,
      error: getErrorMessage(error),
      ...(hint ? { hint } : {}),
    };
  }
}
```

**restart.ts refactoring:**

Current restart.ts does: resolveServer, confirmation prompt, promptApiToken, createProviderWithToken, provider.rebootServer, error handling.

1. Rewrite `restartCommand` to:
   - Keep: `resolveServer()` call
   - Keep: inquirer confirmation prompt
   - Delegate: Call `rebootServer(server.name)` from core/manage.ts
   - Map result: success → spinner.succeed; error → spinner.fail + logger.error + hint

2. Remove direct imports of: `createProviderWithToken`, `promptApiToken` (token now from env via core).

**health.ts refactoring:**

Current health.ts has its own `checkServerHealth()` function that does HTTP check and timing.

1. Keep the `HealthResult` interface and `checkServerHealth` function structure, but import `checkCoolifyHealth` from core/status.ts for the actual HTTP check instead of inline axios call.

2. Refactor `checkServerHealth` to use core: call `checkCoolifyHealth(server.ip)` which already does the axios GET to port 8000.

3. Health command's `healthCommand()` stays as CLI wrapper (formatting, table output).

Each refactored command: separate commit.
  </action>
  <verify>
    <automated>npm run build && npm test -- --testPathPattern="(restart|health|manage)" 2>&1 | tail -10</automated>
  </verify>
  <done>core/manage.ts has rebootServer(). restart.ts delegates to it. health.ts uses core/status.ts. All tests pass.</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. `npm test` passes all tests
3. `grep -rn "provider.destroyServer\|provider.rebootServer" src/commands/` returns nothing (delegated to core)
4. `grep -rn "import.*core/manage" src/commands/add.ts` shows import
5. `grep -rn "import.*core/manage" src/commands/destroy.ts` shows import
6. `grep -rn "import.*core/manage" src/commands/restart.ts` shows import
7. `grep -rn "rebootServer" src/core/manage.ts` shows function definition
</verification>

<success_criteria>
- add, destroy, restart commands delegate business logic to core/manage.ts
- health command uses core/status.ts for health check
- core/manage.ts has new rebootServer function with Result pattern
- All commands only handle CLI concerns (prompts, spinners, output)
- Zero behavior changes
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-cli-core-refactor/01-03-SUMMARY.md`
</output>
