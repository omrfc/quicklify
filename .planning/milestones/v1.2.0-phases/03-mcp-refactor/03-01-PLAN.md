---
phase: 03-mcp-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/mcp/utils.ts
  - src/mcp/server.ts
  - src/commands/restore.ts
  - tests/unit/mcp-utils.test.ts
  - tests/unit/restore-safemode.test.ts
autonomous: true
requirements: [MCP-01, MCP-03]

must_haves:
  truths:
    - "MCP shared utilities exist and provide resolveServer, mcpSuccess, mcpError, requireProviderToken helpers"
    - "restore.ts uses isSafeMode() from core/manage.ts instead of checking SAFE_MODE env var directly"
    - "MCP server version is read from package.json at runtime, not hardcoded"
  artifacts:
    - path: "src/mcp/utils.ts"
      provides: "Shared MCP utility functions"
      exports: ["resolveServerForMcp", "mcpSuccess", "mcpError", "requireProviderToken"]
    - path: "tests/unit/mcp-utils.test.ts"
      provides: "Unit tests for MCP utils"
    - path: "tests/unit/restore-safemode.test.ts"
      provides: "Test for SAFE_MODE env var fix"
  key_links:
    - from: "src/mcp/utils.ts"
      to: "src/utils/config.ts"
      via: "imports getServers, findServer"
      pattern: "import.*from.*config"
    - from: "src/mcp/utils.ts"
      to: "src/core/tokens.ts"
      via: "imports getProviderToken"
      pattern: "import.*from.*tokens"
    - from: "src/commands/restore.ts"
      to: "src/core/manage.ts"
      via: "imports isSafeMode"
      pattern: "isSafeMode\\(\\)"
---

<objective>
Create shared MCP utility module, fix the SAFE_MODE bug in restore.ts, and update server.ts to read version from package.json.

Purpose: Establish the shared utility foundation that Plans 02 and 03 will use to refactor all 7 MCP tools. Fix the P0 security bug where restore.ts checks the wrong environment variable.
Output: `src/mcp/utils.ts` with reusable helpers, `restore.ts` fixed, `server.ts` version dynamic.
</objective>

<execution_context>
@C:/Users/Omrfc/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Omrfc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-mcp-refactor/03-CONTEXT.md

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/utils/config.ts:
```typescript
export function getServers(): ServerRecord[];
export function findServer(query: string): ServerRecord | undefined;
```

From src/core/tokens.ts:
```typescript
export function getProviderToken(provider: string): string | undefined;
```

From src/core/manage.ts:
```typescript
export function isSafeMode(): boolean;
```

From src/utils/errorMapper.ts:
```typescript
export function getErrorMessage(error: unknown): string;
export function mapProviderError(error: unknown, provider: string): string;
export function mapSshError(error: unknown, ip?: string): string;
```

From src/types/index.ts:
```typescript
export type ServerMode = "coolify" | "bare";
export interface ServerRecord {
  id: string;
  name: string;
  provider: string;
  ip: string;
  region: string;
  size: string;
  createdAt: string;
  mode?: ServerMode;
}
```

Existing MCP response pattern (from all 7 tools):
```typescript
// Success pattern
{ content: [{ type: "text", text: JSON.stringify(data) }] }

// Error pattern
{ content: [{ type: "text", text: JSON.stringify({ error, hint?, suggested_actions? }) }], isError: true }
```

Existing resolveServer pattern (duplicated in 4 tools):
```typescript
function resolveServer(params: { server?: string }, servers: ServerRecord[]) {
  if (params.server) return findServer(params.server);
  if (servers.length === 1) return servers[0];
  return undefined;
}
```

restore.ts bug at line 48:
```typescript
// WRONG: checks process.env.SAFE_MODE instead of QUICKLIFY_SAFE_MODE
if (process.env.SAFE_MODE === "true") {
```

server.ts hardcoded version:
```typescript
const pkg = { name: "quicklify-mcp", version: "1.1.0" };
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Create src/mcp/utils.ts shared MCP utility module</name>
  <files>src/mcp/utils.ts, tests/unit/mcp-utils.test.ts</files>
  <behavior>
    - resolveServerForMcp: with server param + findServer match → returns server
    - resolveServerForMcp: with server param + no match → returns undefined
    - resolveServerForMcp: without server param + 1 server → returns that server
    - resolveServerForMcp: without server param + multiple servers → returns undefined
    - resolveServerForMcp: without server param + 0 servers → returns undefined
    - mcpSuccess: wraps data in { content: [{ type: 'text', text: JSON.stringify(data) }] }
    - mcpError: wraps error string in { content: [...], isError: true } with hint and suggested_actions
    - mcpError: includes hint when provided, omits when undefined
    - mcpError: includes suggested_actions when provided, omits when undefined
    - requireProviderToken: returns token when env var is set
    - requireProviderToken: returns MCP error response when token missing
  </behavior>
  <action>
    Create `src/mcp/utils.ts` with these exports:

    1. **`resolveServerForMcp(params: { server?: string }, servers: ServerRecord[]): ServerRecord | undefined`**
       - Import `findServer` from `../../utils/config.js`
       - If `params.server` is provided, return `findServer(params.server)`
       - If only 1 server in list, return `servers[0]`
       - Otherwise return `undefined`

    2. **`mcpSuccess(data: Record<string, unknown>): McpResponse`**
       - Define `McpResponse` type as `{ content: Array<{ type: "text"; text: string }>; isError?: boolean }`
       - Return `{ content: [{ type: "text", text: JSON.stringify(data) }] }`

    3. **`mcpError(error: string, hint?: string, suggestedActions?: Array<{ command: string; reason: string }>): McpResponse`**
       - Build payload object: `{ error, ...(hint ? { hint } : {}), ...(suggestedActions ? { suggested_actions: suggestedActions } : {}) }`
       - Return `{ content: [{ type: "text", text: JSON.stringify(payload) }], isError: true }`

    4. **`requireProviderToken(provider: string): { token: string } | { error: McpResponse }`**
       - Import `getProviderToken` from `../../core/tokens.js`
       - Call `getProviderToken(provider)`
       - If token exists, return `{ token }`
       - If missing, return `{ error: mcpError(\`No API token found for ${provider}\`, \`Set ${provider.toUpperCase()}_TOKEN environment variable\`) }`

    5. Export the `McpResponse` type for use in tool handlers.

    Write tests FIRST in `tests/unit/mcp-utils.test.ts` per the behavior list above.
  </action>
  <verify>
    <automated>npx jest tests/unit/mcp-utils.test.ts --no-coverage</automated>
  </verify>
  <done>src/mcp/utils.ts exports resolveServerForMcp, mcpSuccess, mcpError, requireProviderToken, McpResponse type; all tests pass</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Fix restore.ts SAFE_MODE bug and update server.ts version</name>
  <files>src/commands/restore.ts, src/mcp/server.ts, tests/unit/restore-safemode.test.ts</files>
  <behavior>
    - restore.ts: QUICKLIFY_SAFE_MODE=true blocks restore (isSafeMode() returns true)
    - restore.ts: SAFE_MODE=true does NOT block restore (isSafeMode() checks QUICKLIFY_SAFE_MODE)
    - restore.ts: no SAFE_MODE env vars set → restore proceeds normally
    - server.ts: version matches package.json version at runtime
  </behavior>
  <action>
    **Fix restore.ts (line 47-48):**
    1. Add import at top: `import { isSafeMode } from "../core/manage.js";`
    2. Replace `if (process.env.SAFE_MODE === "true")` with `if (isSafeMode())`
    3. Update the error message from `"Restore is blocked by SAFE_MODE. Set SAFE_MODE=false..."` to `"Restore is blocked by SAFE_MODE. Set QUICKLIFY_SAFE_MODE=false to allow restore operations."`

    **Fix server.ts (line 10):**
    1. Add at top: `import { readFileSync } from "fs";` and `import { fileURLToPath } from "url";` and `import { dirname, join } from "path";`
    2. Replace `const pkg = { name: "quicklify-mcp", version: "1.1.0" };` with:
       ```typescript
       const __filename = fileURLToPath(import.meta.url);
       const __dirname = dirname(__filename);
       const pkgPath = join(__dirname, "..", "..", "package.json");
       const pkg = JSON.parse(readFileSync(pkgPath, "utf-8")) as { name: string; version: string };
       ```
       Note: `src/mcp/server.ts` → `dist/mcp/server.js` → `../../package.json` is correct relative path.

    Write test FIRST for the SAFE_MODE fix in `tests/unit/restore-safemode.test.ts`:
    - Mock `isSafeMode` from `../../src/core/manage` and verify it is called
    - Verify `process.env.SAFE_MODE` is no longer checked

    For server.ts version: no separate test needed — the MCP server test already validates createMcpServer works, and `npm run build` confirms the import compiles.
  </action>
  <verify>
    <automated>npx jest tests/unit/restore-safemode.test.ts --no-coverage && npm run build</automated>
  </verify>
  <done>restore.ts uses isSafeMode() instead of process.env.SAFE_MODE; server.ts reads version from package.json; build succeeds</done>
</task>

</tasks>

<verification>
1. `npm run build` — TypeScript compiles without errors
2. `npx jest tests/unit/mcp-utils.test.ts tests/unit/restore-safemode.test.ts --no-coverage` — new tests pass
3. `npm test` — all existing tests still pass (no regressions)
4. `grep -n "process.env.SAFE_MODE" src/commands/restore.ts` — returns no matches (bug fixed)
5. `grep -n "version.*1.1.0" src/mcp/server.ts` — returns no matches (hardcoded version removed)
</verification>

<success_criteria>
- src/mcp/utils.ts exists with resolveServerForMcp, mcpSuccess, mcpError, requireProviderToken exports
- restore.ts line 48 calls isSafeMode() not process.env.SAFE_MODE
- server.ts reads version dynamically from package.json
- All tests pass including new tests
- Build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-refactor/03-01-SUMMARY.md`
</output>
