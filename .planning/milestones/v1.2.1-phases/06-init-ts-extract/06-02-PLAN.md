---
phase: 06-init-ts-extract
plan: 02
type: tdd
wave: 2
depends_on:
  - "06-01"
files_modified:
  - tests/unit/core-deploy.test.ts
autonomous: true
requirements:
  - REF-03

must_haves:
  truths:
    - "tests/unit/core-deploy.test.ts exists and tests deployServer() in isolation (not through initCommand)"
    - "Tests cover the happy path: successful coolify deployment with saveServer called"
    - "Tests cover bare mode: waitForCoolify NOT called, openBrowser NOT called, SSH info output shown"
    - "Tests cover error path: server creation failure results in process.exit(1)"
    - "Tests cover IP-wait path: pending IP triggers provider refresh loop"
    - "All tests in the new file pass"
    - "All existing tests continue to pass"
  artifacts:
    - path: "tests/unit/core-deploy.test.ts"
      provides: "Unit tests for deployServer() called directly, mocking its dependencies independently of initCommand"
      contains: "import { deployServer } from \"../../src/core/deploy\""
  key_links:
    - from: "tests/unit/core-deploy.test.ts"
      to: "src/core/deploy.ts"
      via: "direct import of deployServer()"
      pattern: "import.*deployServer.*from.*src/core/deploy"
---

<objective>
Write a new test file tests/unit/core-deploy.test.ts that unit-tests deployServer() from src/core/deploy.ts in isolation. Tests call deployServer() directly (not through initCommand) and mock all external dependencies: axios (for cloud provider API), waitForCoolify, saveServer, sshExec, firewallSetup, secureSetup, openBrowser. This provides independent testability of the deployment logic as required by Phase 6 success criterion #5.

Purpose: deployServer() is now independently testable business logic. Unit tests prove it works correctly in isolation and guard against regressions when modifying core deployment behavior without touching the wizard.

Output: tests/unit/core-deploy.test.ts with passing unit tests covering happy path, bare mode, error handling, IP-wait, and full-setup scenarios.
</objective>

<execution_context>
@C:/Users/Omrfc/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Omrfc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-init-ts-extract/06-01-SUMMARY.md

@src/core/deploy.ts
@tests/unit/init-bare.test.ts
@tests/unit/init-fullsetup.test.ts

<interfaces>
<!-- Key contracts deployServer() exposes to tests. -->
<!-- Executor should use these directly — no codebase exploration needed. -->

deployServer() signature (from src/core/deploy.ts after Plan 01):
```typescript
export async function deployServer(
  providerChoice: string,     // e.g. "hetzner"
  providerWithToken: CloudProvider,  // provider instance with token already set
  region: string,             // e.g. "nbg1"
  serverSize: string,         // e.g. "cax11"
  serverName: string,         // e.g. "my-server"
  fullSetup?: boolean,        // if true: run firewallSetup + secureSetup after deployment
  noOpen?: boolean,           // if true: don't open browser after coolify deployment
  mode?: string,              // "bare" | "coolify" | undefined (undefined = coolify)
): Promise<void>
```

Mocked modules (same pattern as init-bare.test.ts):
- `axios` — for Hetzner API calls (createServer = POST, getServerStatus = GET /servers/:id, getServerDetails = GET /servers/:id)
- `../../src/utils/healthCheck` → `{ waitForCoolify: jest.fn() }`
- `../../src/utils/config` → `{ saveServer: jest.fn(), getServers: jest.fn().mockReturnValue([]), ... }`
- `../../src/utils/sshKey` → `{ findLocalSshKey: jest.fn().mockReturnValue(null), generateSshKey: jest.fn().mockReturnValue(null), getSshKeyName: jest.fn().mockReturnValue("quicklify-test") }`
- `../../src/utils/openBrowser` → `{ openBrowser: jest.fn() }`
- `../../src/utils/ssh` → `{ assertValidIp: jest.fn(), sshExec: jest.fn().mockResolvedValue({ code: 0, stdout: "", stderr: "" }), sshConnect: jest.fn(), sshStream: jest.fn(), sanitizedEnv: jest.fn().mockReturnValue({}) }`
- `../../src/commands/firewall` → `{ firewallSetup: jest.fn().mockResolvedValue(undefined), ... }`
- `../../src/commands/secure` → `{ secureSetup: jest.fn().mockResolvedValue(undefined) }`

CloudProvider mock (inline object, not a Jest mock — createProviderWithToken isn't called):
```typescript
const mockProvider: CloudProvider = {
  name: "hetzner",
  displayName: "Hetzner Cloud",
  createServer: jest.fn().mockResolvedValue({ id: "999", ip: "10.0.0.1", status: "running" }),
  getServerStatus: jest.fn().mockResolvedValue("running"),
  getServerDetails: jest.fn().mockResolvedValue({ ip: "10.0.0.1" }),
  uploadSshKey: jest.fn().mockResolvedValue("key-id-1"),
  validateToken: jest.fn().mockResolvedValue(true),
  getAvailableLocations: jest.fn().mockResolvedValue([]),
  getAvailableServerTypes: jest.fn().mockResolvedValue([]),
};
```

Note: Since deployServer() is called directly with a pre-built provider instance, NO axios mocking is needed if you use the mockProvider object above — axios is only used by the real Hetzner provider class (which is bypassed). Use the mockProvider pattern for all tests.
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Write tests/unit/core-deploy.test.ts with deployServer() unit tests</name>
  <files>tests/unit/core-deploy.test.ts</files>
  <behavior>
    - Test 1 (happy path coolify): deployServer("hetzner", mockProvider, "nbg1", "cax11", "my-server") → saveServer called with { mode: "coolify" }, waitForCoolify called
    - Test 2 (bare mode — no waitForCoolify): deployServer(..., mode="bare") → waitForCoolify NOT called
    - Test 3 (bare mode — no openBrowser): deployServer(..., mode="bare") → openBrowser NOT called
    - Test 4 (bare mode — saveServer with mode bare): deployServer(..., mode="bare") → saveServer called with { mode: "bare" }
    - Test 5 (bare mode — SSH info output): deployServer(..., mode="bare") → console.log output contains "ssh root@"
    - Test 6 (bare mode — cloud-init wait): deployServer(..., mode="bare") → sshExec called with "cloud-init status --wait"
    - Test 7 (full-setup coolify): deployServer(..., fullSetup=true) with waitForCoolify=true → firewallSetup and secureSetup both called
    - Test 8 (full-setup skipped when Coolify not ready): deployServer(..., fullSetup=true) with waitForCoolify=false → firewallSetup NOT called
    - Test 9 (server creation failure): mockProvider.createServer rejects with generic error → process.exit(1) called
    - Test 10 (pending IP): mockProvider.createServer returns { ip: "pending" }, getServerDetails returns real IP → saveServer called with real IP
    - Test 11 (noOpen=true): deployServer(..., noOpen=true) with waitForCoolify=true → openBrowser NOT called
    - Test 12 (openBrowser called when ready and noOpen not set): deployServer(..., noOpen=false) with waitForCoolify=true → openBrowser called
  </behavior>
  <action>
Create `tests/unit/core-deploy.test.ts`. Follow the established pattern from tests/unit/init-bare.test.ts (same mock setup pattern, same describe/it/beforeEach/afterEach structure).

**Mock setup (top of file):**
```typescript
import { deployServer } from "../../src/core/deploy";
import type { CloudProvider } from "../../src/providers/base";

jest.mock("../../src/utils/healthCheck", () => ({
  waitForCoolify: jest.fn(),
}));

jest.mock("../../src/utils/config", () => ({
  saveServer: jest.fn(),
  getServers: jest.fn().mockReturnValue([]),
  removeServer: jest.fn(),
  findServer: jest.fn(),
}));

jest.mock("../../src/utils/sshKey", () => ({
  findLocalSshKey: jest.fn().mockReturnValue(null),
  generateSshKey: jest.fn().mockReturnValue(null),
  getSshKeyName: jest.fn().mockReturnValue("quicklify-test"),
}));

jest.mock("../../src/utils/openBrowser", () => ({
  openBrowser: jest.fn(),
}));

jest.mock("../../src/utils/ssh", () => ({
  assertValidIp: jest.fn(),
  sshExec: jest.fn().mockResolvedValue({ code: 0, stdout: "", stderr: "" }),
  sshConnect: jest.fn(),
  sshStream: jest.fn(),
  sanitizedEnv: jest.fn().mockReturnValue({}),
  checkSshAvailable: jest.fn().mockReturnValue(true),
}));

jest.mock("../../src/commands/firewall", () => ({
  firewallSetup: jest.fn().mockResolvedValue(undefined),
  COOLIFY_PORTS: [80, 443, 8000, 6001, 6002],
  BARE_PORTS: [80, 443],
  PROTECTED_PORTS: [22],
  isValidPort: jest.fn(),
  isProtectedPort: jest.fn(),
  buildUfwRuleCommand: jest.fn(),
  buildFirewallSetupCommand: jest.fn(),
  buildBareFirewallSetupCommand: jest.fn(),
  buildUfwStatusCommand: jest.fn(),
  parseUfwStatus: jest.fn(),
}));

jest.mock("../../src/commands/secure", () => ({
  secureSetup: jest.fn().mockResolvedValue(undefined),
}));
```

**Helper function (create mockProvider inline per test or in beforeEach):**
```typescript
function createMockProvider(overrides: Partial<CloudProvider> = {}): CloudProvider {
  return {
    name: "hetzner",
    displayName: "Hetzner Cloud",
    createServer: jest.fn().mockResolvedValue({ id: "999", ip: "10.0.0.1", status: "running" }),
    getServerStatus: jest.fn().mockResolvedValue("running"),
    getServerDetails: jest.fn().mockResolvedValue({ ip: "10.0.0.1" }),
    uploadSshKey: jest.fn().mockResolvedValue("key-id-1"),
    validateToken: jest.fn().mockResolvedValue(true),
    getAvailableLocations: jest.fn().mockResolvedValue([]),
    getAvailableServerTypes: jest.fn().mockResolvedValue([]),
    ...overrides,
  } as CloudProvider;
}
```

**Test structure:**
- `describe("deployServer — coolify mode", () => { ... })` — tests 1, 7, 8, 11, 12
- `describe("deployServer — bare mode", () => { ... })` — tests 2, 3, 4, 5, 6
- `describe("deployServer — error handling", () => { ... })` — test 9
- `describe("deployServer — IP assignment", () => { ... })` — test 10

**Important test nuances:**
- Use `jest.spyOn(process, "exit").mockImplementation(() => undefined as never)` in beforeEach for error tests
- Use `jest.spyOn(console, "log").mockImplementation()` in beforeEach to capture output
- For bare mode sshExec calls: `sshExec` is called first with `"echo ok"` (SSH ready check), then with `"cloud-init status --wait"`. The mock should return `{ code: 0 }` by default.
- For pending IP test: override `createServer` to return `{ id: "999", ip: "pending", status: "running" }` and `getServerDetails` to return `{ ip: "10.0.0.1" }` after one call
- `waitForCoolify` mock must be set in beforeEach (e.g., `mockResolvedValue(true)` for coolify tests, `mockResolvedValue(false)` for "not ready" tests)
- Use `jest.requireMock(...)` pattern to access mock functions (same as init-bare.test.ts)

**Do NOT modify any existing test files.**
  </action>
  <verify>
    <automated>npm test -- --testPathPattern="core-deploy" --verbose 2>&1 | tail -30</automated>
  </verify>
  <done>
- tests/unit/core-deploy.test.ts exists with 12+ tests organized in 4 describe blocks
- All tests in the new file pass
- Tests import deployServer directly from src/core/deploy (not through initCommand)
- All existing tests continue to pass: `npm test` shows no regressions
  </done>
</task>

</tasks>

<verification>
After task completion, run the following checks:

1. **Test file exists:**
```bash
ls tests/unit/core-deploy.test.ts
```
Expected: file exists

2. **Tests import deployServer directly:**
```bash
grep -n "import.*deployServer.*from.*core/deploy" tests/unit/core-deploy.test.ts
```
Expected: 1 match

3. **New tests pass:**
```bash
npm test -- --testPathPattern="core-deploy" 2>&1 | tail -10
```
Expected: all tests pass, no failures

4. **Full test suite passes (no regressions):**
```bash
npm test
```
Expected: all tests pass

5. **Phase 6 success criterion #5 met:**
```bash
grep -c "it(" tests/unit/core-deploy.test.ts
```
Expected: 12 or more test cases
</verification>

<success_criteria>
- tests/unit/core-deploy.test.ts exists (success criterion #5)
- The file contains unit tests for deployServer() called directly (not through initCommand)
- Tests cover: happy path coolify, bare mode (no waitForCoolify, no openBrowser, SSH info, cloud-init wait), full-setup (firewall+secure called/skipped), error path (process.exit), pending IP, noOpen flag
- All new tests pass
- All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/06-init-ts-extract/06-02-SUMMARY.md`
</output>
