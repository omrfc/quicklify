---
phase: 05-scp-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/tokens.ts
  - tests/unit/core-tokens.test.ts
autonomous: true
requirements:
  - SEC-03

must_haves:
  truths:
    - "getProviderToken() returns undefined when the env var value is whitespace-only (e.g., '   ')"
    - "getProviderToken() returns the trimmed token when the env var has leading/trailing whitespace"
    - "getProviderToken() still returns undefined for unknown providers (existing behavior preserved)"
    - "All 2047+ existing tests pass without modification"
  artifacts:
    - path: "src/core/tokens.ts"
      provides: "getProviderToken() with .trim() and whitespace-only guard"
      contains: "trim()"
    - path: "tests/unit/core-tokens.test.ts"
      provides: "Unit tests for whitespace-only and padded token inputs"
      contains: "whitespace"
  key_links:
    - from: "src/core/tokens.ts"
      to: "tests/unit/core-tokens.test.ts"
      via: "getProviderToken whitespace behavior assertions"
      pattern: "whitespace.*undefined|trim"
---

<objective>
Harden `getProviderToken()` in `src/core/tokens.ts` to sanitize token values from environment variables before returning them.

The problem: A user with `HETZNER_TOKEN=   ` (spaces only) in their env would receive a non-undefined whitespace-only string, which would silently pass as an "existing token" but cause API authentication failures downstream.

The fix: Apply `.trim()` to the token value. If the trimmed result is an empty string, return `undefined` — treating whitespace-only tokens the same as missing tokens.

Purpose: Eliminates a class of silent auth failures caused by accidental whitespace in env variable values. Also handles copy-paste artifacts (leading/trailing newlines or spaces).

Output: Updated `src/core/tokens.ts` with one-line change; new test cases in `tests/unit/core-tokens.test.ts` proving whitespace handling.
</objective>

<execution_context>
@C:/Users/Omrfc/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Omrfc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/core/tokens.ts
@tests/unit/core-tokens.test.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/core/tokens.ts (CURRENT — will be hardened):
```typescript
import type { ServerRecord } from "../types/index.js";
import { PROVIDER_ENV_KEYS } from "../constants.js";

export function getProviderToken(provider: string): string | undefined {
  const envKey = PROVIDER_ENV_KEYS[provider as keyof typeof PROVIDER_ENV_KEYS];
  return envKey ? process.env[envKey] : undefined;
}

export function collectProviderTokensFromEnv(
  servers: ServerRecord[],
): Map<string, string> {
  const tokenMap = new Map<string, string>();
  const providers = [
    ...new Set(
      servers.filter((s) => !s.id.startsWith("manual-")).map((s) => s.provider),
    ),
  ];
  for (const provider of providers) {
    const token = getProviderToken(provider);
    if (token) tokenMap.set(provider, token);
  }
  return tokenMap;
}
```

From tests/unit/core-tokens.test.ts (CURRENT — existing tests that must NOT be modified):
```typescript
import { getProviderToken, collectProviderTokensFromEnv } from "../../src/core/tokens";

describe("getProviderToken", () => {
  const originalEnv = process.env;

  beforeEach(() => {
    process.env = { ...originalEnv };
  });

  afterAll(() => {
    process.env = originalEnv;
  });

  it("should return token from HETZNER_TOKEN env var", () => {
    process.env.HETZNER_TOKEN = "hetzner-test-token";
    expect(getProviderToken("hetzner")).toBe("hetzner-test-token");
  });
  // ... (more existing tests — do NOT modify any)
});
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Write failing tests for whitespace-token behavior, then implement the fix</name>
  <files>tests/unit/core-tokens.test.ts, src/core/tokens.ts</files>
  <behavior>
    - Test: getProviderToken() returns undefined when HETZNER_TOKEN is "   " (spaces only)
    - Test: getProviderToken() returns undefined when HETZNER_TOKEN is "\t\n" (tabs/newlines only)
    - Test: getProviderToken() returns the trimmed value when HETZNER_TOKEN is "  my-token  " (padded)
    - Test: getProviderToken() returns the trimmed value when HETZNER_TOKEN is "my-token\n" (trailing newline)
    - Existing tests: all still pass (a clean token "hetzner-test-token" still returns exactly "hetzner-test-token" — trimming a clean token is a no-op)
  </behavior>
  <action>
**Step 1 — Add new tests to tests/unit/core-tokens.test.ts (RED phase):**

Add the following test cases to the EXISTING `describe("getProviderToken", ...)` block, after the last existing test case in that describe. Do NOT remove or modify any existing tests.

```typescript
  it("should return undefined when env var is whitespace-only (spaces)", () => {
    process.env.HETZNER_TOKEN = "   ";
    expect(getProviderToken("hetzner")).toBeUndefined();
  });

  it("should return undefined when env var is whitespace-only (tab + newline)", () => {
    process.env.HETZNER_TOKEN = "\t\n";
    expect(getProviderToken("hetzner")).toBeUndefined();
  });

  it("should return trimmed token when env var has leading whitespace", () => {
    process.env.HETZNER_TOKEN = "  actual-token";
    expect(getProviderToken("hetzner")).toBe("actual-token");
  });

  it("should return trimmed token when env var has trailing whitespace", () => {
    process.env.HETZNER_TOKEN = "actual-token  ";
    expect(getProviderToken("hetzner")).toBe("actual-token");
  });

  it("should return trimmed token when env var has surrounding whitespace", () => {
    process.env.HETZNER_TOKEN = "  actual-token\n";
    expect(getProviderToken("hetzner")).toBe("actual-token");
  });
```

Run tests — these 5 new tests will FAIL (RED) because the current implementation returns the raw env value without trimming.

**Step 2 — Implement the fix in src/core/tokens.ts (GREEN phase):**

The change is a single line. Replace:
```typescript
export function getProviderToken(provider: string): string | undefined {
  const envKey = PROVIDER_ENV_KEYS[provider as keyof typeof PROVIDER_ENV_KEYS];
  return envKey ? process.env[envKey] : undefined;
}
```

With:
```typescript
export function getProviderToken(provider: string): string | undefined {
  const envKey = PROVIDER_ENV_KEYS[provider as keyof typeof PROVIDER_ENV_KEYS];
  const raw = envKey ? process.env[envKey] : undefined;
  const trimmed = raw?.trim();
  return trimmed || undefined;
}
```

Rationale:
- `raw?.trim()` — optional chaining: if `raw` is `undefined`, `trimmed` is also `undefined`
- `trimmed || undefined` — converts empty string `""` (result of trimming whitespace-only string) to `undefined`
- A truthy non-empty string passes through unchanged
- `collectProviderTokensFromEnv()` already checks `if (token)` before inserting — whitespace-only tokens now also correctly skipped there

NOTE: `trimmed || undefined` is the idiomatic pattern here. Do NOT use `trimmed ?? undefined` — that would return `""` for whitespace-only input (the bug we are fixing). `||` treats empty string as falsy, which is exactly the behavior we need.
  </action>
  <verify>
    <automated>cd /c/Users/Omrfc/Documents/quicklify && npx tsc --noEmit 2>&1 | head -10 && npm test -- --testPathPattern="core-tokens" --silent 2>&1 | tail -15</automated>
  </verify>
  <done>All tests in core-tokens.test.ts pass (GREEN), including all 5 new whitespace tests and all pre-existing tests. TypeScript compiles cleanly. The implementation is 3 lines replacing 1 line — no other files were modified.</done>
</task>

<task type="auto">
  <name>Task 2: Full test suite verification</name>
  <files></files>
  <action>
Run the full test suite to confirm all 2047+ existing tests still pass and no regressions were introduced.

```bash
npm test -- --silent 2>&1 | tail -10
npx eslint src/ --max-warnings=0
npm run build
```

If any test fails that previously passed, investigate and fix before marking this plan complete.
  </action>
  <verify>
    <automated>cd /c/Users/Omrfc/Documents/quicklify && npm test -- --silent 2>&1 | tail -10</automated>
  </verify>
  <done>All tests pass (2047+). ESLint reports 0 errors. Build succeeds.</done>
</task>

</tasks>

<verification>
After all tasks complete, run the following checks:

1. **trim() is present in getProviderToken:**
```bash
grep -n 'trim' src/core/tokens.ts
```
Expected: 1+ matches in getProviderToken function

2. **New test cases exist:**
```bash
grep -n 'whitespace\|trimmed\|"   "\|"\t\\\n"' tests/unit/core-tokens.test.ts
```
Expected: multiple matches

3. **All tests pass:**
```bash
npm test
```
Expected: 2047+ tests, 0 failures

4. **Build succeeds:**
```bash
npm run build
```
Expected: clean exit

5. **ESLint passes:**
```bash
npx eslint src/ --max-warnings=0
```
Expected: 0 errors, 0 warnings
</verification>

<success_criteria>
- `getProviderToken("hetzner")` returns `undefined` when `HETZNER_TOKEN="   "` (whitespace-only)
- `getProviderToken("hetzner")` returns `"mytoken"` when `HETZNER_TOKEN="  mytoken  "` (padded)
- `getProviderToken("hetzner")` returns `"mytoken"` when `HETZNER_TOKEN="mytoken\n"` (trailing newline)
- All existing behavior preserved: clean tokens return unchanged, unknown providers return undefined, missing env vars return undefined
- `tests/unit/core-tokens.test.ts` contains at least 5 new whitespace-related test cases
- All 2047+ existing tests pass without modification to previously-existing test cases
- Build and ESLint pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-scp-security-hardening/05-02-SUMMARY.md`
</output>
