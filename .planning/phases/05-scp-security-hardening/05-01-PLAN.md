---
phase: 05-scp-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/constants.ts
  - src/core/backup.ts
  - tests/unit/core-backup.test.ts
autonomous: true
requirements:
  - SEC-01
  - SEC-02

must_haves:
  truths:
    - "SCP spawn calls use stdio: ['ignore', 'pipe', 'pipe'] — stdin is never inherited"
    - "SCP spawn calls include '-o BatchMode=yes' as the second arg pair in the args array"
    - "SCP operations reject with a timeout error when they exceed SCP_TIMEOUT_MS (default 300000ms)"
    - "The spawned SCP child process is killed (SIGTERM) when the timeout fires"
    - "All 2047+ existing tests pass without modification"
  artifacts:
    - path: "src/constants.ts"
      provides: "SCP_TIMEOUT_MS constant (default 300000)"
      contains: "SCP_TIMEOUT_MS"
    - path: "src/core/backup.ts"
      provides: "Hardened scpDownload() and scpUpload() — stdin ignore, BatchMode, timeout"
      contains: "ignore"
    - path: "tests/unit/core-backup.test.ts"
      provides: "Test assertions for stdio, BatchMode, and timeout behaviors"
      contains: "BatchMode=yes"
  key_links:
    - from: "src/constants.ts"
      to: "src/core/backup.ts"
      via: "SCP_TIMEOUT_MS import"
      pattern: "import.*SCP_TIMEOUT_MS.*from.*constants"
    - from: "src/core/backup.ts"
      to: "tests/unit/core-backup.test.ts"
      via: "scpDownload/scpUpload spawn options assertions"
      pattern: "stdio.*ignore"
---

<objective>
Harden `scpDownload()` and `scpUpload()` in `src/core/backup.ts` to be safe in MCP mode (where stdin is used for JSON-RPC transport) and to not hang indefinitely on network failures.

Three concrete changes:
1. **stdin=ignore**: Change `stdio: ["inherit", "pipe", "pipe"]` to `stdio: ["ignore", "pipe", "pipe"]` in both functions — prevents SCP from reading from the MCP JSON-RPC stream
2. **BatchMode=yes**: Add `-o BatchMode=yes` to the SCP args array — prevents SCP from blocking on interactive prompts (password, host key confirmation) in non-interactive environments
3. **Timeout**: Add a `SCP_TIMEOUT_MS` constant (default 300_000ms = 5 minutes) in `constants.ts`; wrap each SCP spawn in a `Promise.race()` against a timeout that kills the child process with SIGTERM and rejects with a descriptive error

Purpose: SEC-01 prevents MCP stream corruption; SEC-02 prevents CLI hang when a remote becomes unreachable mid-transfer.

Output: Updated `src/core/backup.ts` with hardened SCP functions; `src/constants.ts` with new `SCP_TIMEOUT_MS`; new test assertions in `tests/unit/core-backup.test.ts` proving all three behaviors.
</objective>

<execution_context>
@C:/Users/Omrfc/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Omrfc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-scp-security-hardening/05-CONTEXT.md

@src/constants.ts
@src/core/backup.ts
@tests/unit/core-backup.test.ts

<interfaces>
<!-- Key types and contracts the executor needs. Extracted from codebase. -->

From src/core/backup.ts (CURRENT — will be hardened):
```typescript
// scpDownload — BEFORE (line 124-144):
export function scpDownload(
  ip: string,
  remotePath: string,
  localPath: string,
): Promise<{ code: number; stderr: string }> {
  assertValidIp(ip);
  assertSafePath(remotePath);
  return new Promise((resolve) => {
    const child = spawn(
      "scp",
      ["-o", "StrictHostKeyChecking=accept-new", `root@${ip}:${remotePath}`, localPath],
      { stdio: ["inherit", "pipe", "pipe"], env: sanitizedEnv() },  // ← UNSAFE stdin
    );
    let stderr = "";
    child.stderr?.on("data", (data: Buffer) => { stderr += data.toString(); });
    child.on("close", (code) => resolve({ code: code ?? 1, stderr }));
    child.on("error", (err) => resolve({ code: 1, stderr: err.message }));
  });
}

// scpUpload — BEFORE (line 146-166):
export function scpUpload(
  ip: string,
  localPath: string,
  remotePath: string,
): Promise<{ code: number; stderr: string }> {
  assertValidIp(ip);
  assertSafePath(remotePath);
  return new Promise((resolve) => {
    const child = spawn(
      "scp",
      ["-o", "StrictHostKeyChecking=accept-new", localPath, `root@${ip}:${remotePath}`],
      { stdio: ["inherit", "pipe", "pipe"], env: sanitizedEnv() },  // ← UNSAFE stdin
    );
    let stderr = "";
    child.stderr?.on("data", (data: Buffer) => { stderr += data.toString(); });
    child.on("close", (code) => resolve({ code: code ?? 1, stderr }));
    child.on("error", (err) => resolve({ code: 1, stderr: err.message }));
  });
}
```

From src/constants.ts (CURRENT — will receive SCP_TIMEOUT_MS):
```typescript
export const BOOT_MAX_ATTEMPTS = 30;
export const BOOT_INTERVAL = 1000;
// ... (add SCP_TIMEOUT_MS after these, before COOLIFY_UPDATE_CMD)
```

From tests/unit/core-backup.test.ts (CURRENT — existing test imports and mocks):
```typescript
import { spawn } from "child_process";
// ...
const mockedSpawn = spawn as jest.MockedFunction<typeof spawn>;

// Existing createMockProcess helper for spawn mocking:
function createMockProcess(code: number = 0, stderrData: string = "") {
  const proc = new EventEmitter() as any;
  proc.stdout = new EventEmitter();
  proc.stderr = new EventEmitter();
  proc.stdin = null;
  setTimeout(() => {
    if (stderrData) proc.stderr.emit("data", Buffer.from(stderrData));
    proc.emit("close", code);
  }, 10);
  return proc;
}
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add SCP_TIMEOUT_MS constant and write failing tests for SEC-01/SEC-02</name>
  <files>src/constants.ts, tests/unit/core-backup.test.ts</files>
  <behavior>
    - Test: scpDownload spawns with stdio[0] === "ignore" (not "inherit")
    - Test: scpUpload spawns with stdio[0] === "ignore"
    - Test: scpDownload spawn args include "-o BatchMode=yes"
    - Test: scpUpload spawn args include "-o BatchMode=yes"
    - Test: scpDownload rejects with timeout error when SCP hangs past SCP_TIMEOUT_MS (use jest.useFakeTimers())
    - Test: scpUpload rejects with timeout error when SCP hangs (use jest.useFakeTimers())
    - Test: SCP child process is killed (child.kill called with "SIGTERM") on timeout
  </behavior>
  <action>
**Step 1 — Add SCP_TIMEOUT_MS to constants.ts:**

Add after the `BOOT_INTERVAL` line (before `COOLIFY_UPDATE_CMD`):
```typescript
// SCP file transfer timeout — prevents CLI hang on network failures (MCP + interactive mode)
export const SCP_TIMEOUT_MS = 300_000; // 5 minutes
```

**Step 2 — Add new test cases to tests/unit/core-backup.test.ts:**

Add a new `describe` block for SCP security inside the existing `describe("backup", ...)` block (or as a new top-level describe — follow existing file structure). Add the following tests. Import `scpUpload` from the existing import if not already imported.

First, confirm `scpUpload` is imported at the top of the test file. The current import is:
```typescript
import {
  backupCommand,
  formatTimestamp,
  getBackupDir,
  buildPgDumpCommand,
  buildConfigTarCommand,
  buildCleanupCommand,
  buildCoolifyVersionCommand,
  scpDownload,
  listBackups,
  listOrphanBackups,
  cleanupServerBackups,
} from "../../src/commands/backup";
```

NOTE: `backup.test.ts` imports from `../../src/commands/backup` (the command wrapper), while `core-backup.test.ts` imports from `../../src/core/backup` (the core module). The SCP functions live in core. Add the new tests to `tests/unit/core-backup.test.ts` which already imports from `../../src/core/backup`.

Add import for `scpUpload` if it is not already imported (check current imports in core-backup.test.ts — it currently only imports createBareBackup, restoreBareBackup, and pure helpers). Add `scpDownload, scpUpload` to the import list.

Add a new describe block in `tests/unit/core-backup.test.ts`:

```typescript
describe("SCP security hardening (SEC-01, SEC-02)", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  describe("scpDownload", () => {
    it("should spawn with stdio[0] === 'ignore' (not 'inherit')", async () => {
      mockedSpawn.mockReturnValue(createMockProcess(0));
      await scpDownload("1.2.3.4", "/tmp/file.gz", "/local/file.gz");
      const [, , opts] = mockedSpawn.mock.calls[0];
      expect((opts as any).stdio[0]).toBe("ignore");
    });

    it("should include -o BatchMode=yes in SCP args", async () => {
      mockedSpawn.mockReturnValue(createMockProcess(0));
      await scpDownload("1.2.3.4", "/tmp/file.gz", "/local/file.gz");
      const [, args] = mockedSpawn.mock.calls[0];
      const argsStr = (args as string[]).join(" ");
      expect(argsStr).toContain("BatchMode=yes");
    });

    it("should reject with timeout error when SCP hangs", async () => {
      jest.useFakeTimers();
      // Process that never closes
      const hangingProc = new EventEmitter() as any;
      hangingProc.stdout = new EventEmitter();
      hangingProc.stderr = new EventEmitter();
      hangingProc.stdin = null;
      hangingProc.kill = jest.fn();
      mockedSpawn.mockReturnValue(hangingProc);

      const promise = scpDownload("1.2.3.4", "/tmp/file.gz", "/local/file.gz");
      jest.advanceTimersByTime(300_001);
      await expect(promise).rejects.toThrow(/timeout/i);
      jest.useRealTimers();
    });

    it("should kill the child process (SIGTERM) on timeout", async () => {
      jest.useFakeTimers();
      const hangingProc = new EventEmitter() as any;
      hangingProc.stdout = new EventEmitter();
      hangingProc.stderr = new EventEmitter();
      hangingProc.stdin = null;
      hangingProc.kill = jest.fn();
      mockedSpawn.mockReturnValue(hangingProc);

      const promise = scpDownload("1.2.3.4", "/tmp/file.gz", "/local/file.gz");
      jest.advanceTimersByTime(300_001);
      await promise.catch(() => {});
      expect(hangingProc.kill).toHaveBeenCalledWith("SIGTERM");
      jest.useRealTimers();
    });
  });

  describe("scpUpload", () => {
    it("should spawn with stdio[0] === 'ignore' (not 'inherit')", async () => {
      mockedSpawn.mockReturnValue(createMockProcess(0));
      await scpUpload("1.2.3.4", "/local/file.gz", "/tmp/file.gz");
      const [, , opts] = mockedSpawn.mock.calls[0];
      expect((opts as any).stdio[0]).toBe("ignore");
    });

    it("should include -o BatchMode=yes in SCP args", async () => {
      mockedSpawn.mockReturnValue(createMockProcess(0));
      await scpUpload("1.2.3.4", "/local/file.gz", "/tmp/file.gz");
      const [, args] = mockedSpawn.mock.calls[0];
      const argsStr = (args as string[]).join(" ");
      expect(argsStr).toContain("BatchMode=yes");
    });

    it("should reject with timeout error when SCP hangs", async () => {
      jest.useFakeTimers();
      const hangingProc = new EventEmitter() as any;
      hangingProc.stdout = new EventEmitter();
      hangingProc.stderr = new EventEmitter();
      hangingProc.stdin = null;
      hangingProc.kill = jest.fn();
      mockedSpawn.mockReturnValue(hangingProc);

      const promise = scpUpload("1.2.3.4", "/local/file.gz", "/tmp/file.gz");
      jest.advanceTimersByTime(300_001);
      await expect(promise).rejects.toThrow(/timeout/i);
      jest.useRealTimers();
    });

    it("should kill the child process (SIGTERM) on timeout", async () => {
      jest.useFakeTimers();
      const hangingProc = new EventEmitter() as any;
      hangingProc.stdout = new EventEmitter();
      hangingProc.stderr = new EventEmitter();
      hangingProc.stdin = null;
      hangingProc.kill = jest.fn();
      mockedSpawn.mockReturnValue(hangingProc);

      const promise = scpUpload("1.2.3.4", "/local/file.gz", "/tmp/file.gz");
      jest.advanceTimersByTime(300_001);
      await promise.catch(() => {});
      expect(hangingProc.kill).toHaveBeenCalledWith("SIGTERM");
      jest.useRealTimers();
    });
  });
});
```

At this point the new tests FAIL (RED) because backup.ts still uses `stdio: ["inherit", ...]` and has no timeout.
  </action>
  <verify>
    <automated>cd /c/Users/Omrfc/Documents/quicklify && npx tsc --noEmit 2>&1 | head -10 && npm test -- --testPathPattern="core-backup" --silent 2>&1 | tail -20</automated>
  </verify>
  <done>SCP_TIMEOUT_MS exported from constants.ts. New test cases exist in core-backup.test.ts and FAIL (RED) because the implementation is not yet updated. TypeScript compiles (constants.ts change is non-breaking).</done>
</task>

<task type="auto">
  <name>Task 2: Harden scpDownload() and scpUpload() — stdin ignore, BatchMode, timeout (GREEN)</name>
  <files>src/core/backup.ts</files>
  <action>
Import `SCP_TIMEOUT_MS` from constants and update both SCP functions. Replace the existing implementations with the hardened versions:

**Add to imports at top of src/core/backup.ts:**
```typescript
import { SCP_TIMEOUT_MS } from "../constants.js";
```

**Replace `scpDownload()` (lines 124-144) with:**
```typescript
export function scpDownload(
  ip: string,
  remotePath: string,
  localPath: string,
  timeoutMs: number = SCP_TIMEOUT_MS,
): Promise<{ code: number; stderr: string }> {
  assertValidIp(ip);
  assertSafePath(remotePath);
  return new Promise((resolve, reject) => {
    // stdin must be "ignore" — not "inherit". MCP uses stdin for JSON-RPC transport;
    // inheriting it would corrupt the stream. BatchMode=yes prevents interactive prompts.
    const child = spawn(
      "scp",
      ["-o", "BatchMode=yes", "-o", "StrictHostKeyChecking=accept-new", `root@${ip}:${remotePath}`, localPath],
      { stdio: ["ignore", "pipe", "pipe"], env: sanitizedEnv() },
    );
    let stderr = "";
    child.stderr?.on("data", (data: Buffer) => {
      stderr += data.toString();
    });
    child.on("close", (code) => resolve({ code: code ?? 1, stderr }));
    child.on("error", (err) => resolve({ code: 1, stderr: err.message }));

    const timer = setTimeout(() => {
      child.kill("SIGTERM");
      reject(new Error(`SCP download timed out after ${timeoutMs}ms`));
    }, timeoutMs);
    // Clear timer when the process exits normally
    child.on("close", () => clearTimeout(timer));
    child.on("error", () => clearTimeout(timer));
  });
}
```

**Replace `scpUpload()` (lines 146-166) with:**
```typescript
export function scpUpload(
  ip: string,
  localPath: string,
  remotePath: string,
  timeoutMs: number = SCP_TIMEOUT_MS,
): Promise<{ code: number; stderr: string }> {
  assertValidIp(ip);
  assertSafePath(remotePath);
  return new Promise((resolve, reject) => {
    // stdin must be "ignore" — not "inherit". MCP uses stdin for JSON-RPC transport;
    // inheriting it would corrupt the stream. BatchMode=yes prevents interactive prompts.
    const child = spawn(
      "scp",
      ["-o", "BatchMode=yes", "-o", "StrictHostKeyChecking=accept-new", localPath, `root@${ip}:${remotePath}`],
      { stdio: ["ignore", "pipe", "pipe"], env: sanitizedEnv() },
    );
    let stderr = "";
    child.stderr?.on("data", (data: Buffer) => {
      stderr += data.toString();
    });
    child.on("close", (code) => resolve({ code: code ?? 1, stderr }));
    child.on("error", (err) => resolve({ code: 1, stderr: err.message }));

    const timer = setTimeout(() => {
      child.kill("SIGTERM");
      reject(new Error(`SCP upload timed out after ${timeoutMs}ms`));
    }, timeoutMs);
    // Clear timer when the process exits normally
    child.on("close", () => clearTimeout(timer));
    child.on("error", () => clearTimeout(timer));
  });
}
```

**Important implementation notes:**
- The `timeoutMs` parameter has a default value, so existing call sites (`createBackup`, `createBareBackup`, `restoreBackup`, `restoreBareBackup`) need NO changes — they call `scpDownload(ip, remote, local)` with 3 args and get the 300s default.
- The `child.on("close", () => clearTimeout(timer))` prevents the timer from firing after a normal exit. The listener is registered twice (once to resolve, once to clear) — this is fine because Node.js EventEmitter supports multiple listeners.
- Both `resolve` and `reject` may be called from different code paths. The Promise constructor only honors the first call; subsequent calls are no-ops. This is safe.
- The `timeoutMs` parameter is exported in the function signature for testability — tests can pass a small value to avoid `jest.advanceTimersByTime`.

After implementing, the 8 new tests in core-backup.test.ts must turn GREEN.
  </action>
  <verify>
    <automated>cd /c/Users/Omrfc/Documents/quicklify && npx tsc --noEmit 2>&1 | head -10 && npm test -- --testPathPattern="core-backup" --silent 2>&1 | tail -20</automated>
  </verify>
  <done>All tests in core-backup.test.ts pass (GREEN). scpDownload and scpUpload both use stdio: ["ignore", "pipe", "pipe"] and include -o BatchMode=yes. Both reject with timeout error after SCP_TIMEOUT_MS. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 3: Full test suite verification</name>
  <files></files>
  <action>
Run the full test suite to confirm all 2047+ existing tests still pass and no regressions were introduced.

```bash
npm test -- --silent 2>&1 | tail -10
npx eslint src/ --max-warnings=0
npm run build
```

If any test fails that previously passed, investigate and fix before marking this plan complete.
  </action>
  <verify>
    <automated>cd /c/Users/Omrfc/Documents/quicklify && npm test -- --silent 2>&1 | tail -10</automated>
  </verify>
  <done>All tests pass (2047+). ESLint reports 0 errors. Build succeeds.</done>
</task>

</tasks>

<verification>
After all tasks complete, run the following checks:

1. **stdin is "ignore" in both SCP functions:**
```bash
grep -n '"ignore"' src/core/backup.ts
```
Expected: 2 matches (one per function), showing `stdio: ["ignore", "pipe", "pipe"]`

2. **BatchMode=yes is in both SCP arg arrays:**
```bash
grep -n 'BatchMode=yes' src/core/backup.ts
```
Expected: 2 matches

3. **SCP_TIMEOUT_MS is exported from constants.ts:**
```bash
grep -n 'SCP_TIMEOUT_MS' src/constants.ts
```
Expected: 1 match

4. **New test assertions exist:**
```bash
grep -n 'BatchMode=yes\|ignore.*stdio\|stdio.*ignore' tests/unit/core-backup.test.ts
```
Expected: multiple matches

5. **All tests pass:**
```bash
npm test
```
Expected: 2047+ tests, 0 failures

6. **Build succeeds:**
```bash
npm run build
```
Expected: clean exit
</verification>

<success_criteria>
- `scpDownload()` and `scpUpload()` both spawn with `stdio: ["ignore", "pipe", "pipe"]`
- Both SCP functions include `-o BatchMode=yes` in their args array (before `-o StrictHostKeyChecking=accept-new`)
- Both SCP functions reject with a descriptive timeout error after `SCP_TIMEOUT_MS` ms (default 300_000)
- The spawned child process is killed with SIGTERM on timeout
- `src/constants.ts` exports `SCP_TIMEOUT_MS = 300_000`
- `tests/unit/core-backup.test.ts` contains assertions for stdio[0]==="ignore", BatchMode=yes, and timeout behavior
- All 2047+ existing tests pass without modification to previously-existing test cases
- Build and ESLint pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-scp-security-hardening/05-01-SUMMARY.md`
</output>
