---
phase: 02-bare-mode
plan: 04
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - src/core/backup.ts
  - src/commands/backup.ts
  - src/commands/restore.ts
autonomous: true
requirements: [BARE-07]

must_haves:
  truths:
    - "Bare server backup copies /etc/ config files (nginx, sshd, ufw, crontab)"
    - "Bare server backup does NOT attempt Coolify DB dump"
    - "Bare server backup manifest includes mode:'bare'"
    - "Bare server restore restores config files, does NOT attempt Coolify start/stop"
    - "SAFE_MODE protection applies to bare restore (same as Coolify restore)"
    - "Coolify backup/restore behavior unchanged"
  artifacts:
    - path: "src/core/backup.ts"
      provides: "Bare backup/restore functions"
      exports: ["createBareBackup", "restoreBareBackup", "buildBareConfigTarCommand", "buildBareRestoreConfigCommand"]
    - path: "src/commands/backup.ts"
      provides: "Mode-aware backup command"
      contains: "isBareServer"
    - path: "src/commands/restore.ts"
      provides: "Mode-aware restore command"
      contains: "isBareServer"
  key_links:
    - from: "src/commands/backup.ts"
      to: "src/core/backup.ts"
      via: "createBareBackup import"
      pattern: "createBareBackup"
    - from: "src/commands/restore.ts"
      to: "src/core/backup.ts"
      via: "restoreBareBackup import"
      pattern: "restoreBareBackup"
    - from: "src/commands/backup.ts"
      to: "src/utils/modeGuard.ts"
      via: "isBareServer for routing"
      pattern: "isBareServer"
---

<objective>
Implement bare server backup and restore that targets system configuration files instead of Coolify database.

Purpose: Bare servers have no Coolify DB to back up. Instead, backup targets system config files under /etc/ (nginx, sshd_config, ufw rules, crontab). The restore operation puts these files back and leaves service restart to the user. SAFE_MODE protection applies equally.
Output: Working `quicklify backup` and `quicklify restore` for bare servers with system config focus.
</objective>

<execution_context>
@C:/Users/Omrfc/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Omrfc/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-bare-mode/02-CONTEXT.md
@.planning/phases/02-bare-mode/02-01-SUMMARY.md
@.planning/phases/02-bare-mode/02-02-SUMMARY.md

<interfaces>
<!-- Contracts from Plan 01 and existing code -->

From src/utils/modeGuard.ts:
```typescript
export function isBareServer(server: ServerRecord): boolean;
export function getServerMode(server: ServerRecord): ServerMode;
```

From src/core/backup.ts (existing):
```typescript
export function formatTimestamp(date: Date): string;
export function getBackupDir(serverName: string): string;
export function listBackups(serverName: string): string[];
export function loadManifest(backupPath: string): BackupManifest | undefined;
export function scpDownload(ip, remotePath, localPath): Promise<{code, stderr}>;
export function scpUpload(ip, localPath, remotePath): Promise<{code, stderr}>;

export interface BackupResult {
  success: boolean;
  backupPath?: string;
  manifest?: BackupManifest;
  error?: string;
  hint?: string;
}

export interface RestoreResult {
  success: boolean;
  steps: Array<{ name: string; status: "success" | "failure"; error?: string }>;
  error?: string;
  hint?: string;
}

export async function createBackup(ip, serverName, provider): Promise<BackupResult>;
export async function restoreBackup(ip, serverName, backupId): Promise<RestoreResult>;
```

From src/types/index.ts (after Plan 01):
```typescript
export interface BackupManifest {
  serverName: string;
  provider: string;
  timestamp: string;
  coolifyVersion: string;
  files: string[];
  mode?: "coolify" | "bare";
}
```
</interfaces>
</context>

<tasks>

<task type="auto" tdd="true">
  <name>Task 1: Add bare backup/restore functions to core/backup.ts</name>
  <files>src/core/backup.ts, tests/unit/core-backup.test.ts</files>
  <behavior>
    - Test: buildBareConfigTarCommand() produces tar command targeting /etc/nginx, /etc/ssh/sshd_config, /etc/ufw, /etc/crontab, /etc/fail2ban
    - Test: buildBareRestoreConfigCommand() produces tar extract to /etc/
    - Test: createBareBackup calls sshExec with bare tar command (not pg_dump)
    - Test: createBareBackup writes manifest with mode:'bare' and coolifyVersion:'n/a'
    - Test: createBareBackup downloads single tar file (not DB dump + config)
    - Test: restoreBareBackup uploads and extracts config tar (no Coolify stop/start)
    - Test: restoreBareBackup does NOT call buildStopCoolifyCommand or buildStartCoolifyCommand
  </behavior>
  <action>
    Add the following to `src/core/backup.ts`:

    1. **Pure functions for bare backup commands:**
       ```typescript
       export function buildBareConfigTarCommand(): string {
         // Tar up key system config directories/files
         // Use --ignore-failed-read to handle missing optional paths
         return "tar czf /tmp/bare-config.tar.gz --ignore-failed-read " +
           "-C / " +
           "etc/nginx " +
           "etc/ssh/sshd_config " +
           "etc/ufw " +
           "etc/fail2ban " +
           "etc/crontab " +
           "etc/apt/apt.conf.d/50unattended-upgrades " +
           "2>/dev/null || tar czf /tmp/bare-config.tar.gz -C / etc/ssh/sshd_config";
       }

       export function buildBareRestoreConfigCommand(): string {
         return "tar xzf /tmp/bare-config.tar.gz -C /";
       }

       export function buildBareCleanupCommand(): string {
         return "rm -f /tmp/bare-config.tar.gz";
       }
       ```

    2. **createBareBackup function:**
       ```typescript
       export async function createBareBackup(
         ip: string,
         serverName: string,
         provider: string,
       ): Promise<BackupResult> {
         assertValidIp(ip);
         try {
           // Step 1: Create config archive on server
           const configResult = await sshExec(ip, buildBareConfigTarCommand());
           if (configResult.code !== 0) {
             return { success: false, error: "Config backup failed", hint: sanitizeStderr(configResult.stderr) || undefined };
           }

           // Step 2: Download
           const timestamp = formatTimestamp(new Date());
           const backupPath = join(getBackupDir(serverName), timestamp);
           mkdirSync(backupPath, { recursive: true, mode: 0o700 });

           const dl = await scpDownload(ip, "/tmp/bare-config.tar.gz", join(backupPath, "bare-config.tar.gz"));
           if (dl.code !== 0) {
             return { success: false, error: "Failed to download config backup", hint: sanitizeStderr(dl.stderr) || undefined };
           }

           // Step 3: Write manifest
           const manifest: BackupManifest = {
             serverName,
             provider,
             timestamp,
             coolifyVersion: "n/a",
             files: ["bare-config.tar.gz"],
             mode: "bare",
           };
           writeFileSync(join(backupPath, "manifest.json"), JSON.stringify(manifest, null, 2), { mode: 0o600 });

           // Step 4: Cleanup remote
           await sshExec(ip, buildBareCleanupCommand()).catch(() => {});

           return { success: true, backupPath, manifest };
         } catch (error: unknown) {
           const hint = mapSshError(error, ip);
           return { success: false, error: getErrorMessage(error), ...(hint ? { hint } : {}) };
         }
       }
       ```

    3. **restoreBareBackup function:**
       ```typescript
       export async function restoreBareBackup(
         ip: string,
         serverName: string,
         backupId: string,
       ): Promise<RestoreResult> {
         assertValidIp(ip);
         const baseDir = getBackupDir(serverName);
         const backupPath = join(baseDir, backupId);

         // Path traversal guard
         if (!resolve(backupPath).startsWith(resolve(baseDir))) {
           return { success: false, steps: [], error: "Invalid backupId: path traversal detected" };
         }

         const steps: Array<{ name: string; status: "success" | "failure"; error?: string }> = [];
         const manifest = loadManifest(backupPath);
         if (!manifest) {
           return { success: false, steps, error: `Backup not found or corrupt: ${backupId}` };
         }

         // Verify backup file exists
         const configFile = join(backupPath, "bare-config.tar.gz");
         if (!existsSync(configFile)) {
           return { success: false, steps, error: "Missing backup file: bare-config.tar.gz" };
         }

         try {
           // Upload config archive
           const upload = await scpUpload(ip, configFile, "/tmp/bare-config.tar.gz");
           if (upload.code !== 0) {
             return { success: false, steps: [{ name: "Upload config", status: "failure", error: sanitizeStderr(upload.stderr) }], error: "Upload failed" };
           }
           steps.push({ name: "Upload config", status: "success" });

           // Extract config
           const restoreResult = await sshExec(ip, buildBareRestoreConfigCommand());
           if (restoreResult.code !== 0) {
             steps.push({ name: "Restore config", status: "failure", error: sanitizeStderr(restoreResult.stderr) });
             return { success: false, steps, error: "Config restore failed" };
           }
           steps.push({ name: "Restore config", status: "success" });

           // Cleanup
           await sshExec(ip, buildBareCleanupCommand()).catch(() => {});

           return { success: true, steps };
         } catch (error: unknown) {
           const hint = mapSshError(error, ip);
           return { success: false, steps, error: getErrorMessage(error), ...(hint ? { hint } : {}) };
         }
       }
       ```

    4. Update existing backup tests and add new tests for bare functions.
  </action>
  <verify>
    <automated>npx jest tests/unit/core-backup.test.ts --no-coverage 2>&1 | tail -10</automated>
  </verify>
  <done>createBareBackup and restoreBareBackup work correctly, manifest has mode:'bare', no Coolify commands executed</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Route backup/restore commands by server mode</name>
  <files>src/commands/backup.ts, src/commands/restore.ts, tests/unit/backup.test.ts, tests/unit/restore.test.ts</files>
  <behavior>
    - Test: backupCommand on bare server calls createBareBackup (not createBackup)
    - Test: backupCommand on coolify server calls createBackup (existing behavior)
    - Test: backupCommand --all handles mixed bare+coolify servers, routing each correctly
    - Test: restoreCommand on bare server calls restoreBareBackup (not restoreBackup)
    - Test: restoreCommand on coolify server calls restoreBackup (existing behavior)
    - Test: restoreCommand respects SAFE_MODE for bare servers
  </behavior>
  <action>
    1. **src/commands/backup.ts** -- Route by mode:
       - Import `isBareServer` from `../utils/modeGuard.js`
       - Import `createBareBackup` from `../core/backup.js`
       - After resolving server, check `isBareServer(server)`:
         - If bare: call `createBareBackup(server.ip, server.name, server.provider)` instead of `createBackup()`
         - If coolify: existing `createBackup()` call unchanged
       - Adjust spinner text for bare: "Backing up system config..." instead of "Backing up Coolify..."
       - For `--all` mode: iterate servers, route each by mode

    2. **src/commands/restore.ts** -- Route by mode:
       - Import `isBareServer` from `../utils/modeGuard.js`
       - Import `restoreBareBackup` from `../core/backup.js`
       - After resolving server, check `isBareServer(server)`:
         - If bare: call `restoreBareBackup()` instead of `restoreBackup()`
         - If coolify: existing `restoreBackup()` call unchanged
       - SAFE_MODE check should apply before the mode branch (it already does for Coolify -- confirm it's at command level, not core level)
       - After bare restore success, show message: "Config files restored. Restart affected services manually (nginx, ssh, ufw, etc.)"

    3. Update existing backup/restore command tests with mode-aware routing.
  </action>
  <verify>
    <automated>npx jest tests/unit/backup.test.ts tests/unit/restore.test.ts --no-coverage 2>&1 | tail -10</automated>
  </verify>
  <done>Backup/restore commands route to bare or coolify functions based on server mode, SAFE_MODE applies to both, existing behavior unchanged</done>
</task>

</tasks>

<verification>
- `npm run build` succeeds
- `npm test` passes all existing + new tests
- `npm run lint` passes
- Bare backup targets /etc/ config files
- Bare restore extracts config without Coolify stop/start
- Manifest includes mode:'bare'
- Coolify backup/restore unchanged
- SAFE_MODE protects bare restore
</verification>

<success_criteria>
- `quicklify backup <bare-server>` backs up system config files (not Coolify DB)
- `quicklify restore <bare-server>` restores config files (not Coolify)
- Manifest JSON includes mode:'bare' for bare backups
- SAFE_MODE=true blocks bare restore
- Coolify backup/restore behavior is identical to before
- All tests pass, build + lint clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-bare-mode/02-04-SUMMARY.md`
</output>
